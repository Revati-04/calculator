/**
 * Shell-sdk Librarys
 *
 * @author Phoenix(github.com/azusa0127)
 * @version 0.2.0
 */
/**
 * ============================================================================
 * Requires.
 * ============================================================================
 */
const fs = require(`fspp-ext`);
const path = require(`path`);
const {spawn} = require(`child_process`);
/**
 * ============================================================================
 * Library.
 * ============================================================================
 */
const scriptsdk = {
  IS_WINDOWS: process.platform === `win32`,
  IS_LINUX: process.platform === `linux`,
  /**
   * An Uncomplicated Logger
   *
   * @param {any} [Options] Optional initialization options.
   * @param {string|number} [Options.level] Output level. Can be level string or its array index.
   * @param {string|Buffer} [Options.prefix] Prefix label.
   * @param {number} [Options.indent] Existing indentation length.
   * @param {Writable} [Options.outStream] An writable Stream
   */
  Logger: class {
    constructor({level, prefix, indent, outStream} = {}) {
      this.LEVELS = [`error`, `warn`, `info`, `log`, `debug`, `trace`];
      this.logLevel = level
        ? typeof level === `string` ? this.LEVELS.indexOf(level) : level
        : this.LEVELS.indexOf(`info`);
      this.logPrefix = prefix && prefix.length ? `[${prefix}]` : ``;
      this.logIndent = indent && typeof indent === `number` ? indent : 0;
      this.Console = outStream ? new console.Console(outStream, outStream) : console;
    }

    /**
     * Internal write function, controls output template and output level control.
     *
     * @param {any} data Data to be written.
     * @param {string|number} [channel=`info`] Log Channel. Can be level string or its array index.
     * @param {string|Buffer} [prefix=null] Prefix label. uses logPrefix if null.
     */
    _write(data, channel = `info`, prefix = null) {
      if ((typeof channel === `string` ? this.LEVELS.indexOf(channel) : channel) <= this.logLevel) {
        // Debug output optimization
        if (typeof data !== `string` && (channel === `debug` || channel === this.LEVELS.indexOf(`debug`)))
          data = JSON.stringify(data, null, 2);

        const timeStamp = new Date().toLocaleString();
        if (prefix && prefix.length) prefix = `<${prefix}>`;
        const template = `${timeStamp} |${channel.toUpperCase()}| ${prefix ? `${` `.repeat(this.logIndent + this.logPrefix.length)} ${prefix}` : `${this.logPrefix}${` `.repeat(this.logIndent)}`} ${data}`;
        switch (channel) {
          case `error`:
          case `warn`:
            this.Console.error(template);
            break;
          case `info`:
          case `log`:
          case `debug`:
            this.Console.log(template);
            break;
          case `trace`:
            this.Console.trace(template);
            break;
          default:
            throw new Error(`Invalid Channel ${channel}!`);
        }
      }
    }
    /**
     * Log data on `error` channel with Console.error().
     *
     * @param {any} data Data to be written.
     * @param {string|Buffer} [prefix=``] Prefix label.
     */
    error(data, prefix = ``) { this._write(data, `error`, prefix); }
    /**
     * Log data on `warn` channel with Console.error().
     *
     * @param {any} data Data to be written.
     * @param {string|Buffer} [prefix=``] Prefix label.
     */
    warn(data, prefix = ``) { this._write(data, `warn`, prefix); }
    /**
     * Log data on `info` channel with Console.log().
     *
     * @param {any} data Data to be written.
     * @param {string|Buffer} [prefix=``] Prefix label.
     */
    info(data, prefix = ``) { this._write(data, `info`, prefix); }
    /**
     * Log data on `log` channel with Console.log().
     *
     * @param {any} data Data to be written.
     * @param {string|Buffer} [prefix=``] Prefix label.
     */
    log(data, prefix = ``) { this._write(data, `log`, prefix); }
    /**
     * Log data on `debug` channel with Console.log().
     *
     * @param {any} data Data to be written.
     * @param {string|Buffer} [prefix=``] Prefix label.
     */
    debug(data, prefix = ``) { this._write(data, `debug`, prefix); }
    /**
     * Log data on `trace` channel with Console.trace().
     *
     * @param {any} data Data to be written.
     * @param {string|Buffer} [prefix=``] Prefix label.
     */
    trace(data, prefix = null) { this._write(data, `trace`, prefix); }

    /**
     * Group the following logger calls by block and increase indentation.
     *
     * @param {string|Buffer} [label=``] Group label.
     * @param {string|number} [channel=`info`] Log Channel. Can be level string or its array index.
     */
    enterBlock(label = ``, channel = `info`) {
      this._write(`${label} Begin...`, channel);
      this.logIndent += 2;
    }
    /**
     * Ending the logger call block and decrease indentation.
     *
     * @param {string|Buffer} [label=``] Group label.
     * @param {string|number} [channel=`info`] Log Channel. Can be level string or its array index.
     */
    exitBlock(label = ``, channel = `info`) {
      this.logIndent -= 2;
      this._write(`${label} Completed!`, channel);
    }

    /**
     * Set Logger Output Level.
     * LEVELS = [ `error`, `warn`, `info`, `log`, `debug`, `trace` ];
     *
     * @param {string|number} level Can be level string or its array index.
     */
    setLogLevel(level) {
      this.logLevel = typeof level === `string` ? this.LEVELS.indexOf(level) : level;
      this.info(`LogLevel = ${level}.`);
    }
  },
  /**
   * Asynchronizely execute a shell command. fails when the exit code is non-zero.
   *
   * @param {string} command : shell command.
   * @param {string[]} [args=[]] : arguments for the command.
   * @param {Object} [Options] Optional Options
   *
   * @param {bool} [Options.verbose] If also output the data to console or logger lively.
   * @param {Logger|console.Console} [Options.logger] logger to be used with verbose output.
   * @param {string} [Options.cwd] Working directory for the command execution.
   * @param {Object} [Options.env] Environment vars for the command execution.
   * @param {bool|string} [Options.shell] The shell command to run.
   *
   * @return {{code, stdout, stderr [, message]}}
   */
  simpleExec: async (command, args = [], {cwd = process.cwd(), env = process.env, shell = true, verbose = false, logger = console} = {}) =>
    new Promise((resolve, reject) => {
      let stdout = ``,
        stderr = ``;
      const cmd = spawn(command, args, {cwd, env, shell});
      cmd.stdout.on(`data`, chunk => {
        stdout += `${chunk}`;
        if (verbose) logger.log(`${chunk}`);
      });
      cmd.stderr.on(`data`, chunk => {
        stderr += `${chunk}`;
        if (verbose) logger.error(`${chunk}`);
      });
      cmd.on(`error`, err => reject(err));
      cmd.on(`close`, code => code
        ? reject(Object.assign(new Error(`Command "${command} ${args}" failed with code ${code}`), {code, stdout, stderr}))
        : resolve({code, stdout, stderr}));
    }),
  /**
   * Compressed file extractiong function. Using unzip and tar on Linux and PowerShell on windows.
   *
   * @param {string} compressed file path.
   * @param {string} targetPath target directory for archive to be extracted to.
   * @param {Logger} logger logger instance for debug output.
   * @exception Promise will be rejected if the extraction fails.
   *
   * @return {{code, stdout, stderr [, message]}}
   */
  async extract(compressed, targetPath = null, logger = null) {
    if (logger) logger.debug(`extract("${compressed}"${targetPath ? `, "${targetPath}"` : ``})...`, `extract`);
    const ABSOLUTE_PATH = path.isAbsolute(compressed) ? path.normalize(compressed) : path.resolve(compressed);
    const RELATIVE_PATH = path.relative(process.cwd(), ABSOLUTE_PATH);
    await fs.access(ABSOLUTE_PATH, fs.R_OK);
    const DST_PATH = targetPath
      ? path.isAbsolute(targetPath) ? path.normalize(targetPath) : path.resolve(targetPath)
      : path.dirname(ABSOLUTE_PATH);
    await fs.ensurePath(DST_PATH);

    let extract_command;
    switch (process.platform) {
      case `linux`:
        if (compressed.endsWith(`.tar.gz`))
          extract_command = `tar -xvf "${RELATIVE_PATH}" -C "${DST_PATH}"`;
        else extract_command = `unzip "${compressed}" <<< A`;
        break;
      case `win32`:
        extract_command = `powershell.exe -NoLogo -NoProfile -Command "Expand-Archive -Path '${compressed}' -DestinationPath '${DST_PATH}' -Force"`;
        break;
      default:
        throw new Error(
          `Unexpected Platform ${process.platform} - this script can only handle linux or windows`,
        );
    }
    return scriptsdk.simpleExec(extract_command);
  },
  /**
   * Compressed folder function. Using tar on Linux and PowerShell on windows.
   *
   * @param {string} dirToCompress directory to be compressed.
   * @param {string} targetPath target directory/file path for archive.
   * @param {Logger} logger logger instance for debug output.
   * @exception Promise will be rejected if the extraction fails.
   *
   * @return {{code, stdout, stderr [, message]}}
   */
  async compress(dirToCompress, targetPath = null, logger = null) {
    if (logger) logger.debug(`compress("${dirToCompress}"${targetPath ? `, "${targetPath}"` : ``})...`, `compress`);
    dirToCompress = path.isAbsolute(dirToCompress) ? path.normalize(dirToCompress) : path.resolve(dirToCompress);
    if (targetPath) targetPath = path.isAbsolute(targetPath) ? path.normalize(targetPath) : path.resolve(targetPath);
    await fs.access(dirToCompress, fs.R_OK);
    const SRC_DIR = path.dirname(dirToCompress);
    const SRC_NAME = path.basename(dirToCompress);
    const DST_PATH =
      (targetPath.endsWith(`.zip`) && scriptsdk.IS_WINDOWS) || (targetPath.endsWith(`.tar.gz`) && scriptsdk.IS_LINUX) ? targetPath : path.join(targetPath, `${SRC_NAME}${scriptsdk.IS_WINDOWS ? `.zip` : `.tar.gz`}`);
    await fs.ensurePath(path.dirname(DST_PATH));

    let compress_command;
    switch (process.platform) {
      case `linux`:
        compress_command = `tar -czvf "${DST_PATH}" -C "${SRC_DIR}" "${SRC_NAME}"`;
        break;
      case `win32`:
        compress_command = `powershell.exe -NoLogo -NoProfile -Command "Compress-Archive -Path '${dirToCompress}' -DestinationPath '${DST_PATH}' -Force"`;
        break;
      default:
        throw new Error(
          `Unexpected Platform ${process.platform} - this script can only handle linux or windows`,
        );
    }
    return scriptsdk.simpleExec(compress_command);
  },
};
/**
 * ============================================================================
 * Exports.
 * ============================================================================
 */
module.exports = scriptsdk;
